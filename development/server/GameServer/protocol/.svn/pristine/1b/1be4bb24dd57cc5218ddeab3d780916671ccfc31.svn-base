# -*- coding:utf-8 -*-
# @Time        : 2019/8/17 17:07
# @Author      : liyihang@corp.netease.com
# @File        : __init__.py
# @Description : 
# @API         :
from __future__ import division

import math

import numpy as np

from protocol.pb2.Struct.CommonStruct_pb2 import *


def to_vec(self):
    return np.array([self.x, self.y, self.z])


def euc_distance(self, other):
    pos1 = self.to_vec()
    pos2 = other.to_vec()
    return np.linalg.norm(pos1 - pos2)


def vec3_add(self, other):
    x = self.x + other.x
    y = self.y + other.y
    z = self.z + other.z
    return NetVector3(x=x, y=y, z=z)


NetVector3.to_vec = to_vec

NetVector3.euc_distance = euc_distance

NetVector3.__add__ = vec3_add


def normalize(v):
    norm = np.linalg.norm(v, ord=1)
    if norm == 0:
        norm = np.finfo(v.dtype).eps
    return v / norm


def quaternion_look_rotation(forward, up):
    forward = forward.to_vec()
    up = up.to_vec()

    vector = normalize(forward)
    vector2 = normalize(np.cross(up, vector))
    vector3 = np.cross(vector, vector2)

    m00 = vector2[0]
    m01 = vector2[1]
    m02 = vector2[2]

    m10 = vector3[0]
    m11 = vector3[1]
    m12 = vector3[2]

    m20 = vector[0]
    m21 = vector[1]
    m22 = vector[2]

    num8 = (m00 + m11) + m22
    quaternion = NetQuaternion()
    if num8 > 0:
        num = math.sqrt(num8 + 1)
        quaternion.w = num * 0.5
        num = 0.5 / num
        quaternion.x = (m12 - m21) * num
        quaternion.y = (m20 - m02) * num
        quaternion.z = (m01 - m10) * num
        return quaternion

    if m00 >= m11 and m00 >= m22:
        num7 = math.sqrt(((1 + m00) - m11) - m22)
        num4 = 0.5 / num7
        quaternion.x = 0.5 * num7
        quaternion.y = (m01 + m10) * num4
        quaternion.z = (m02 + m20) * num4
        quaternion.w = (m12 - m21) * num4
        return quaternion

    if m11 > m22:
        num6 = math.sqrt(((1 + m11) - m00) - m22)
        num3 = 0.5 / num6
        quaternion.x = (m10 + m01) * num3
        quaternion.y = 0.5 * num6
        quaternion.z = (m21 + m12) * num3
        quaternion.w = (m20 - m02) * num3
        return quaternion

    num5 = math.sqrt(((1 + m22) - m00) - m11)
    num2 = 0.5 / num5
    quaternion.x = (m20 + m02) * num2
    quaternion.y = (m21 + m12) * num2
    quaternion.z = 0.5 * num5
    quaternion.w = (m01 - m10) * num2
    return quaternion
